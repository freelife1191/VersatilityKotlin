# 6-5 제네릭: 파라미터 타입의 가변성과 제약사항

## 타입 불변성
코틀린은 Banana가 Fruit을 상속받았더라도 `Array<Banana>`를 `Array<Fruit>`으로 취급해서 전달하는 것을 막아서 제네릭을 타입 안정적으로 만들었다

`Array<T>`는 `class Array<T>`로 정의되며 `List<T>`는 interface List<out E>로 정의한다

## 공변성 사용하기
코틀린에서는 from 파라미터는 파라미터의 값을 읽기만 하기 때문에 `Array<T>`의 T에 Fruit 클래스나 Fruit 클래스의 하위 클래스가 전달되어도 아무런 위험이 없다
이런 것을 타입이나 파생 타입에 접근하기 위한 파라미터 타입의 공변성이라고 이야기 한다

`Array<T>` 클래스는 T타입의 객체를 읽고, 쓰는 메소드 모두를 가지고 있다
`Array<T>`를 사용하는 모든 함수는 읽고, 쓰는 두 타입의 메소드를 사용할 수 있다
하지만 공변성을 사용하기 위해서 우리가 코틀린 컴파일러에게 주어진 `Array<T>` 파라미터에서 어떤 값도 추가하거나 
변경하지 않겠다는 약속을 해야 한다
이런 제네릭 클래스를 사용하는 관점에서 공변성을 이용하는 걸 사용처 가변성(use-site variance)혹은 타입 프로젝션 이라고 부른다

사용처 가변성은 제네릭 클래스를 공변성으로 사용하려 할 때 유용하다
하지만 더 넓은 수준에서 볼 때 제네릭 클래스를 만든 사람은 해당 클래스를 사용하는 모든 사람이 클래스를 사용할 때 값을 읽고
쓰는 것 모두 가능하게 하여 공변성을 사용할 수 있도록 만든 것이다

제네릭  타입을 사용할 때가 아니라 선언할 때 공변성을 사용한다고 지정하는 것을 선언처 가변성(declation-site variance)이라고 부른다
선언처 가변성의 좋은 예제는 `List<out T>`로 되어있는 List 인터페이스의 정의에서 찾아볼 수 있다

`List<out T>`로 선언 가변성 정의가 되어있기 때문에 `List<Banana>`를 receiveFruits() 메소드에 전달할 수 있는 권한을 얻을 수 있다
`List<out T>`는 코틀린에게 receiveFruits()를 비롯해 이와 유사한 모든 메소드들에서 `List<T>`에 변경이나 추가가 없다는 것을 보장해준다

반대로 `Array<out T>`는 코틀린에게 `Array<out T>`의 공변성 파라미터에 변경이나 추가가 없다는 것을 보장해준다
선언 가변성은 적용된 파라미터에만 사용 가변성(use-site variance)과 같이 작용한다

공변성을 사용하면 컴파일러에게 자식 클래스를 부모 클래스의 자리에 사용할 수 있게 요청할 수 있다

## 반공변성 사용하기
`<in T>`로 정의되면 전체적으로 파라미터 타입을 받을 수만 있고 리턴하거나 다른 곳으로 보낼 수 없는 반공변성으로 특정된다

## where를 사용한 파라미터 타입 제한

## 스타 프로젝션
파라미터 타입을 정의하는 스타 프로젝션(Star projection)`<*>`은 제네릭 읽기전용 타입과 raw타입을 위한 코틀린의 기능이다

스타 프로젝션은 타입에 대해 정확히는 알 수 없지만 타입 안정성을 유지하면서 파라미터를 전달할 때 사용하면된다
스타 프로젝션은 읽는 것만 허용하고 쓰는 것은 허용하지 않는다

스타 프로젝션은 부주의한 오류로부터 보호해준다
프로젝션`<*>`은 out T 와 동일하지만 더 간결하게 작성할 수 있다
스타 프로젝션이 선언처 가변성에서 `<in T>`로 정의된 반공분산으로 사용된다면 in Nothing을 사용한 것과 같아진다
이 점을 강조하기 위해서 아무거나 사용하더라도 컴파일 에러가 발생할 것이다
스타 프로젝션은 모든 작성(쓰기)을 방지하고 안정성까지 제공해준다